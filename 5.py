import heapq

graph = [[(1, 50), (5, 40)],
         [(0, 50), (2, 15)],
         [(1, 15), (3, 35), (4, 35)],
         [(2, 35), (4, 35), (12, 40), (13, 45)],
         [(2, 35), (3, 35), (5, 35), (9, 45)],
         [(0, 40), (4, 35), (6, 45), (9, 50)],
         [(5, 45), (7, 35), (9, 35)],
         [(6, 35), (8, 30), (9, 35), (10, 35)],
         [(7, 30), (10, 30)],
         [(4, 45), (5, 50), (6, 35), (7, 35), (10, 35), (11, 35), (12, 35)],
         [(7, 35), (8, 30), (9, 35), (11, 35), (14, 40)],
         [(9, 35), (10, 35), (12, 10), (14, 40)],
         [(3, 40), (9, 35), (11, 10), (13, 35), (17, 50)],
         [(3, 45), (12, 35)],
         [(10, 40), (11, 40)],
         [(14, 40), (16, 15), (18, 45)],
         [(15, 15), (17, 35), (18, 40)],
         [(12, 50), (13, 45), (16, 35), (19, 40)],
         [(15, 45), (16, 40), (19, 35), (20, 35), (21, 40)],
         [(17, 40), (18, 35), (22, 40)],
         [(18, 35), (21, 45)],
         [(18, 40), (20, 45), (22, 15)],
         [(19, 40), (21, 15)]]

def prim(graph, start):
    cost, seen = 0, set([start])

    while len(seen) < len(graph):
        moves = []
        for x in seen:
            for neighbour_city, salt in graph[x]:
                if neighbour_city not in seen:
                    heapq.heappush(moves, (salt, neighbour_city))
        
        salt, neighbour_city = heapq.heappop(moves)
        seen.add(neighbour_city)
        cost += salt

    return cost

print(min([prim(graph, vertex_i) for vertex_i in range(len(graph))]))